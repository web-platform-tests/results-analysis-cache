{"status":"OK","subtests":[{"name":"addTrack when pc is closed should throw InvalidStateError","status":"PASS"},{"name":"addTrack with single track argument and no stream should succeed","status":"PASS"},{"name":"addTrack with single track argument and single stream should succeed","status":"PASS"},{"name":"addTrack with single track argument and multiple streams should succeed","status":"PASS"},{"name":"Adding the same track multiple times should throw InvalidAccessError","status":"PASS"},{"name":"addTrack with existing sender with null track, same kind, and recvonly direction should reuse sender","status":"PASS"},{"name":"addTrack with existing sender that has not been used to send should reuse the sender","status":"PASS"},{"name":"addTrack with existing sender that has been used to send should create new sender","status":"PASS"},{"name":"addTrack with existing sender with null track, different kind, and recvonly direction should create new sender","status":"PASS"},{"name":"Adding more tracks does not generate more candidates if bundled","status":"PASS"},{"name":"Calling addTrack while sRD(offer) is pending should allow the new remote transceiver to be the same one that addTrack creates","status":"PASS"},{"name":"When addTrack is called while sRD is in progress, and both addTrack and sRD add a transceiver of different media types, the addTrack transceiver should come first, and then the sRD transceiver.","status":"PASS"}]}