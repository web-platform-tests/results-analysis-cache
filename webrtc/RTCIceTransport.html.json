{"status":"TIMEOUT","subtests":[{"name":"Two connected iceTransports should have matching local/remote candidates returned","status":"FAIL"},{"name":"Unconnected iceTransport should have empty remote candidates and selected pair","status":"PASS"},{"name":"RTCIceTransport should be in state \"new\" initially","status":"PASS"},{"name":"RTCIceTransport should transition to \"gathering\" then \"complete\", after sLD","status":"FAIL"},{"name":"PC.close() should not cause the RTCIceTransport gathering state to transition to \"complete\"","status":"FAIL"},{"name":"RTCIceTransport should transition to \"gathering\", then \"complete\" after sLD (DataChannel case)","status":"PASS"},{"name":"RTCIceTransport should not transition to \"checking\" until after the answer is set _and_ the first remote candidate is received","status":"PASS"},{"name":"RTCIceTransport should transition to \"disconnected\" if packets stop flowing","status":"FAIL"},{"name":"RTCIceTransport should transition to \"disconnected\" if packets stop flowing (DataChannel case)","status":"FAIL"},{"name":"Local ICE restart should not result in a different ICE transport","status":"PASS"},{"name":"Local ICE restart should not result in a different ICE transport (DataChannel case)","status":"PASS"},{"name":"Remote ICE restart should not result in a different ICE transport","status":"PASS"},{"name":"Remote ICE restart should not result in a different ICE transport (DataChannel case)","status":"PASS"},{"name":"RTCIceTransport should transition to \"closed\" if the underlying transport is closed because the answer used bundle","status":"TIMEOUT"},{"name":"RTCIceTransport should synchronously transition to \"closed\" with no event if the underlying transport is closed due to PC.close()","status":"NOTRUN"}]}