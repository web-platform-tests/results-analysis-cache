{"status":"OK","subtests":[{"name":"CustomElementRegistry interface must have define as a method","status":"PASS"},{"name":"customElements.define must throw when the element interface is not a constructor","status":"PASS"},{"name":"customElements.define must not throw the constructor is HTMLElement","status":"PASS"},{"name":"customElements.define must throw with an invalid name","status":"PASS"},{"name":"customElements.define must throw when there is already a custom element of the same name","status":"PASS"},{"name":"customElements.define must throw a NotSupportedError when there is already a custom element with the same class","status":"PASS"},{"name":"customElements.define must throw a NotSupportedError when element definition is running flag is set","status":"PASS"},{"name":"customElements.define must check IsConstructor on the constructor before checking the element definition is running flag","status":"PASS"},{"name":"customElements.define must validate the custom element name before checking the element definition is running flag","status":"PASS"},{"name":"customElements.define unset the element definition is running flag before upgrading custom elements","status":"PASS"},{"name":"customElements.define must not throw when defining another custom element in a different global object during Get(constructor, \"prototype\")","status":"FAIL"},{"name":"Custom Elements: CustomElementRegistry interface","status":"PASS"},{"name":"customElements.define must get \"prototype\", \"disabledFeatures\", and \"formAssociated\" property of the constructor","status":"FAIL"},{"name":"customElements.define must rethrow an exception thrown while getting \"prototype\" property of the constructor","status":"PASS"},{"name":"customElements.define must throw when \"prototype\" property of the constructor is not an object","status":"PASS"},{"name":"customElements.define must get callbacks of the constructor prototype","status":"FAIL"},{"name":"customElements.define must rethrow an exception thrown while getting callbacks on the constructor prototype","status":"FAIL"},{"name":"customElements.define must rethrow an exception thrown while converting a callback value to Function callback type","status":"FAIL"},{"name":"customElements.define must get \"observedAttributes\" property on the constructor prototype when \"attributeChangedCallback\" is present","status":"FAIL"},{"name":"customElements.define must rethrow an exception thrown while getting observedAttributes on the constructor prototype","status":"PASS"},{"name":"customElements.define must rethrow an exception thrown while converting the value of observedAttributes to sequence<DOMString>","status":"PASS"},{"name":"customElements.define must rethrow an exception thrown while iterating over observedAttributes to sequence<DOMString>","status":"PASS"},{"name":"customElements.define must rethrow an exception thrown while retrieving Symbol.iterator on observedAttributes","status":"PASS"},{"name":"customElements.define must not throw even if \"observedAttributes\" fails to convert if \"attributeChangedCallback\" is not defined","status":"PASS"},{"name":"customElements.define must rethrow an exception thrown while getting disabledFeatures on the constructor prototype","status":"PASS"},{"name":"customElements.define must rethrow an exception thrown while converting the value of disabledFeatures to sequence<DOMString>","status":"PASS"},{"name":"customElements.define must rethrow an exception thrown while iterating over disabledFeatures to sequence<DOMString>","status":"PASS"},{"name":"customElements.define must rethrow an exception thrown while retrieving Symbol.iterator on disabledFeatures","status":"PASS"},{"name":"customElements.define must rethrow an exception thrown while getting formAssociated on the constructor prototype","status":"FAIL"},{"name":"customElements.define must get four additional callbacks on the prototype if formAssociated is converted to true","status":"FAIL"},{"name":"customElements.define must rethrow an exception thrown while getting additional formAssociated callbacks on the constructor prototype","status":"FAIL"},{"name":"customElements.define must define an instantiatable custom element","status":"PASS"},{"name":"customElements.define must upgrade elements in the shadow-including tree order","status":"PASS"},{"name":"CustomElementRegistry interface must have get as a method","status":"PASS"},{"name":"customElements.get must return undefined when the registry does not contain an entry with the given name","status":"PASS"},{"name":"customElements.get must return undefined when the registry does not contain an entry with the given name even if the name was not a valid custom element name","status":"PASS"},{"name":"customElements.get return the constructor of the entry with the given name when there is a matching entry.","status":"PASS"},{"name":"customElements.whenDefined must return a promise for a valid custom element name","status":"PASS"},{"name":"customElements.whenDefined must return the same promise each time invoked for a valid custom element name which has not been defined","status":"PASS"},{"name":"customElements.whenDefined must return an unresolved promise when the registry does not contain the entry with the given name","status":"PASS"},{"name":"customElements.whenDefined must return a rejected promise when the given name is not a valid custom element name","status":"PASS"},{"name":"customElements.whenDefined must return a resolved promise when the registry contains the entry with the given name","status":"PASS"},{"name":"customElements.whenDefined must return a new resolved promise each time invoked when the registry contains the entry with the given name","status":"PASS"},{"name":"A promise returned by customElements.whenDefined must be resolved by \"define\"","status":"PASS"}]}