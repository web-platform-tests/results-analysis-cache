{"status":"OK","subtests":[{"name":"Aborting rejects with AbortError","status":"PASS"},{"name":"Aborting rejects with AbortError - no-cors","status":"PASS"},{"name":"TypeError from request constructor takes priority - RequestInit's window is not null","status":"PASS"},{"name":"TypeError from request constructor takes priority - Input URL is not valid","status":"PASS"},{"name":"TypeError from request constructor takes priority - Input URL has credentials","status":"PASS"},{"name":"TypeError from request constructor takes priority - RequestInit's mode is navigate","status":"PASS"},{"name":"TypeError from request constructor takes priority - RequestInit's referrer is invalid","status":"PASS"},{"name":"TypeError from request constructor takes priority - RequestInit's method is invalid","status":"PASS"},{"name":"TypeError from request constructor takes priority - RequestInit's method is forbidden","status":"PASS"},{"name":"TypeError from request constructor takes priority - RequestInit's mode is no-cors and method is not simple","status":"PASS"},{"name":"TypeError from request constructor takes priority - RequestInit's cache mode is only-if-cached and mode is not same-origin","status":"PASS"},{"name":"TypeError from request constructor takes priority - Request with cache mode: only-if-cached and fetch mode cors","status":"PASS"},{"name":"TypeError from request constructor takes priority - Request with cache mode: only-if-cached and fetch mode no-cors","status":"PASS"},{"name":"TypeError from request constructor takes priority - Bad referrerPolicy init parameter value","status":"PASS"},{"name":"TypeError from request constructor takes priority - Bad mode init parameter value","status":"PASS"},{"name":"TypeError from request constructor takes priority - Bad credentials init parameter value","status":"PASS"},{"name":"TypeError from request constructor takes priority - Bad cache init parameter value","status":"PASS"},{"name":"TypeError from request constructor takes priority - Bad redirect init parameter value","status":"PASS"},{"name":"Request objects have a signal property","status":"PASS"},{"name":"Signal on request object","status":"PASS"},{"name":"Signal on request object created from request object","status":"PASS"},{"name":"Signal on request object created from request object, with signal on second request","status":"PASS"},{"name":"Signal on request object created from request object, with signal on second request overriding another","status":"PASS"},{"name":"Signal retained after unrelated properties are overridden by fetch","status":"PASS"},{"name":"Signal removed by setting to null","status":"PASS"},{"name":"Already aborted signal rejects immediately","status":"PASS"},{"name":"Request is still 'used' if signal is aborted before fetching","status":"PASS"},{"name":"response.arrayBuffer() rejects if already aborted","status":"PASS"},{"name":"response.blob() rejects if already aborted","status":"PASS"},{"name":"response.formData() rejects if already aborted","status":"PASS"},{"name":"response.json() rejects if already aborted","status":"PASS"},{"name":"response.text() rejects if already aborted","status":"PASS"},{"name":"Already aborted signal does not make request","status":"PASS"},{"name":"Already aborted signal can be used for many fetches","status":"PASS"},{"name":"Signal can be used to abort other fetches, even if another fetch succeeded before aborting","status":"PASS"},{"name":"Underlying connection is closed when aborting after receiving response","status":"PASS"},{"name":"Underlying connection is closed when aborting after receiving response - no-cors","status":"PASS"},{"name":"Fetch aborted & connection closed when aborted after calling response.arrayBuffer()","status":"PASS"},{"name":"Fetch aborted & connection closed when aborted after calling response.blob()","status":"PASS"},{"name":"Fetch aborted & connection closed when aborted after calling response.formData()","status":"PASS"},{"name":"Fetch aborted & connection closed when aborted after calling response.json()","status":"PASS"},{"name":"Fetch aborted & connection closed when aborted after calling response.text()","status":"PASS"},{"name":"Stream errors once aborted. Underlying connection closed.","status":"PASS"},{"name":"Stream errors once aborted, after reading. Underlying connection closed.","status":"PASS"},{"name":"Stream will not error if body is empty. It's closed with an empty queue before it errors.","status":"FAIL"},{"name":"Readable stream synchronously cancels with AbortError if aborted before reading","status":"FAIL"},{"name":"Signal state is cloned","status":"PASS"},{"name":"Clone aborts with original controller","status":"PASS"}]}