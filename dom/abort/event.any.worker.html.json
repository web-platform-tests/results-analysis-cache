{"status":"OK","subtests":[{"name":"AbortController abort() should fire event synchronously","status":"PASS"},{"name":"controller.signal should always return the same object","status":"PASS"},{"name":"controller.abort() should do nothing the second time it is called","status":"PASS"},{"name":"event handler should not be called if added after controller.abort()","status":"PASS"},{"name":"the abort event should have the right properties","status":"PASS"},{"name":"AbortController abort(reason) should set signal.reason","status":"PASS"},{"name":"aborting AbortController without reason creates an \"AbortError\" DOMException","status":"PASS"},{"name":"AbortController abort(undefined) creates an \"AbortError\" DOMException","status":"PASS"},{"name":"AbortController abort(null) should set signal.reason","status":"PASS"},{"name":"static aborting signal should have right properties","status":"PASS"},{"name":"static aborting signal with reason should set signal.reason","status":"PASS"},{"name":"throwIfAborted() should throw abort.reason if signal aborted","status":"PASS"},{"name":"throwIfAborted() should throw primitive abort.reason if signal aborted","status":"PASS"},{"name":"throwIfAborted() should not throw if signal not aborted","status":"PASS"},{"name":"AbortSignal.reason returns the same DOMException","status":"PASS"},{"name":"AbortController.signal.reason returns the same DOMException","status":"PASS"}]}