{"status":"OK","subtests":[{"name":"getReader({mode: \"byob\"}) throws on non-bytes streams","status":"FAIL"},{"name":"ReadableStream with byte source can be constructed with no errors","status":"FAIL"},{"name":"getReader({mode}) must perform ToString()","status":"FAIL"},{"name":"ReadableStream with byte source: Construct and expect start and pull being called","status":"FAIL"},{"name":"ReadableStream with byte source: No automatic pull call if start doesn't finish","status":"FAIL"},{"name":"ReadableStream with byte source: Construct with highWaterMark of 0","status":"FAIL"},{"name":"ReadableStream with byte source: desiredSize when closed","status":"FAIL"},{"name":"ReadableStream with byte source: desiredSize when errored","status":"FAIL"},{"name":"ReadableStream with byte source: getReader(), then releaseLock()","status":"FAIL"},{"name":"ReadableStream with byte source: getReader() with mode set to byob, then releaseLock()","status":"FAIL"},{"name":"ReadableStream with byte source: Test that closing a stream does not release a reader automatically","status":"FAIL"},{"name":"ReadableStream with byte source: Test that closing a stream does not release a BYOB reader automatically","status":"FAIL"},{"name":"ReadableStream with byte source: Test that erroring a stream does not release a reader automatically","status":"FAIL"},{"name":"ReadableStream with byte source: Test that erroring a stream does not release a BYOB reader automatically","status":"FAIL"},{"name":"ReadableStream with byte source: releaseLock() on ReadableStreamReader with pending read() must throw","status":"FAIL"},{"name":"ReadableStream with byte source: Automatic pull() after start()","status":"FAIL"},{"name":"ReadableStream with byte source: Automatic pull() after start() and read()","status":"FAIL"},{"name":"ReadableStream with byte source: autoAllocateChunkSize","status":"FAIL"},{"name":"ReadableStream with byte source: Mix of auto allocate and BYOB","status":"FAIL"},{"name":"ReadableStream with byte source: Automatic pull() after start() and read(view)","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue(), getReader(), then read()","status":"FAIL"},{"name":"ReadableStream with byte source: Push source that doesn't understand pull signal","status":"FAIL"},{"name":"ReadableStream with byte source: pull() function is not callable","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue() with Uint16Array, getReader(), then read()","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue(), read(view) partially, then read()","status":"FAIL"},{"name":"ReadableStream with byte source: getReader(), enqueue(), close(), then read()","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue(), close(), getReader(), then read()","status":"FAIL"},{"name":"ReadableStream with byte source: Respond to pull() by enqueue()","status":"FAIL"},{"name":"ReadableStream with byte source: Respond to pull() by enqueue() asynchronously","status":"FAIL"},{"name":"ReadableStream with byte source: Respond to multiple pull() by separate enqueue()","status":"FAIL"},{"name":"ReadableStream with byte source: read(view), then respond()","status":"FAIL"},{"name":"ReadableStream with byte source: read(view), then respond() with a transferred ArrayBuffer","status":"FAIL"},{"name":"ReadableStream with byte source: read(view), then respond() with too big value","status":"FAIL"},{"name":"ReadableStream with byte source: respond(3) to read(view) with 2 element Uint16Array enqueues the 1 byte remainder","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue(), getReader(), then read(view)","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue(), getReader(), then cancel() (mode = not BYOB)","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue(), getReader(), then cancel() (mode = BYOB)","status":"FAIL"},{"name":"ReadableStream with byte source: getReader(), read(view), then cancel()","status":"FAIL"},{"name":"ReadableStream with byte source: cancel() with partially filled pending pull() request","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue(), getReader(), then read(view) where view.buffer is not fully covered by view","status":"FAIL"},{"name":"ReadableStream with byte source: Multiple enqueue(), getReader(), then read(view)","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue(), getReader(), then read(view) with a bigger view","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue(), getReader(), then read(view) with a smaller views","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue() 1 byte, getReader(), then read(view) with Uint16Array","status":"FAIL"},{"name":"ReadableStream with byte source: enqueue() 3 byte, getReader(), then read(view) with 2-element Uint16Array","status":"FAIL"},{"name":"ReadableStream with byte source: read(view) with Uint16Array on close()-d stream with 1 byte enqueue()-d must fail","status":"FAIL"},{"name":"ReadableStream with byte source: A stream must be errored if close()-d before fulfilling read(view) with Uint16Array","status":"FAIL"},{"name":"ReadableStream with byte source: Throw if close()-ed more than once","status":"FAIL"},{"name":"ReadableStream with byte source: Throw on enqueue() after close()","status":"FAIL"},{"name":"ReadableStream with byte source: read(view), then respond() and close() in pull()","status":"FAIL"},{"name":"ReadableStream with byte source: read(view) with Uint32Array, then fill it by multiple respond() calls","status":"FAIL"},{"name":"ReadableStream with byte source: read() twice, then enqueue() twice","status":"FAIL"},{"name":"ReadableStream with byte source: Multiple read(view), close() and respond()","status":"FAIL"},{"name":"ReadableStream with byte source: Multiple read(view), big enqueue()","status":"FAIL"},{"name":"ReadableStream with byte source: Multiple read(view) and multiple enqueue()","status":"FAIL"},{"name":"ReadableStream with byte source: read(view) with passing undefined as view must fail","status":"FAIL"},{"name":"ReadableStream with byte source: read(view) with zero-length view must fail","status":"FAIL"},{"name":"ReadableStream with byte source: read(view) with passing an empty object as view must fail","status":"FAIL"},{"name":"ReadableStream with byte source: Even read(view) with passing ArrayBufferView like object as view must fail","status":"FAIL"},{"name":"ReadableStream with byte source: read() on an errored stream","status":"FAIL"},{"name":"ReadableStream with byte source: read(), then error()","status":"FAIL"},{"name":"ReadableStream with byte source: read(view) on an errored stream","status":"FAIL"},{"name":"ReadableStream with byte source: read(view), then error()","status":"FAIL"},{"name":"ReadableStream with byte source: Throwing in pull function must error the stream","status":"FAIL"},{"name":"ReadableStream with byte source: Throwing in pull in response to read() must be ignored if the stream is errored in it","status":"FAIL"},{"name":"ReadableStream with byte source: Throwing in pull in response to read(view) function must error the stream","status":"FAIL"},{"name":"ReadableStream with byte source: Throwing in pull in response to read(view) must be ignored if the stream is errored in it","status":"FAIL"},{"name":"calling respond() twice on the same byobRequest should throw","status":"FAIL"},{"name":"calling respondWithNewView() twice on the same byobRequest should throw","status":"FAIL"},{"name":"calling respond(0) twice on the same byobRequest should throw even when closed","status":"FAIL"},{"name":"pull() resolving should not make releaseLock() possible","status":"FAIL"},{"name":"ReadableStream with byte source: default reader + autoAllocateChunkSize + byobRequest interaction","status":"FAIL"},{"name":"ReadableStreamBYOBReader can be constructed directly","status":"FAIL"},{"name":"ReadableStreamBYOBReader constructor requires a ReadableStream argument","status":"FAIL"},{"name":"ReadableStreamBYOBReader constructor requires an unlocked ReadableStream","status":"FAIL"},{"name":"ReadableStreamBYOBReader constructor requires a ReadableStream with type \"bytes\"","status":"FAIL"},{"name":"ReadableStream constructor should not accept a strategy with a size defined if type is \"bytes\"","status":"PASS"}]}