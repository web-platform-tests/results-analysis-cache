{"status":"OK","subtests":[{"name":"Piping must lock both the ReadableStream and WritableStream","status":"PASS"},{"name":"Piping finishing must unlock both the ReadableStream and WritableStream","status":"PASS"},{"name":"pipeTo must check the brand of its ReadableStream this value","status":"PASS"},{"name":"pipeTo must check the brand of its WritableStream argument","status":"PASS"},{"name":"pipeTo must fail if the ReadableStream is locked, and not lock the WritableStream","status":"PASS"},{"name":"pipeTo must fail if the WritableStream is locked, and not lock the ReadableStream","status":"PASS"},{"name":"Piping from a ReadableStream from which lots of chunks are synchronously readable","status":"PASS"},{"name":"Piping from a ReadableStream for which a chunk becomes asynchronously readable after the pipeTo","status":"PASS"},{"name":"an undefined rejection from pull should cause pipeTo() to reject when preventAbort is true","status":"PASS"},{"name":"an undefined rejection from pull should cause pipeTo() to reject when preventAbort is false","status":"PASS"},{"name":"an undefined rejection from write should cause pipeTo() to reject when preventCancel is true","status":"PASS"},{"name":"an undefined rejection from write should cause pipeTo() to reject when preventCancel is false","status":"PASS"}]}