{"status":"OK","subtests":[{"name":"Piping must lock both the ReadableStream and WritableStream","status":"FAIL"},{"name":"Piping finishing must unlock both the ReadableStream and WritableStream","status":"FAIL"},{"name":"pipeTo must check the brand of its ReadableStream this value","status":"FAIL"},{"name":"pipeTo must check the brand of its WritableStream argument","status":"FAIL"},{"name":"pipeTo must fail if the ReadableStream is locked, and not lock the WritableStream","status":"FAIL"},{"name":"pipeTo must fail if the WritableStream is locked, and not lock the ReadableStream","status":"FAIL"},{"name":"Piping from a ReadableStream from which lots of chunks are synchronously readable","status":"FAIL"},{"name":"Piping from a ReadableStream for which a chunk becomes asynchronously readable after the pipeTo","status":"FAIL"},{"name":"an undefined rejection from pull should cause pipeTo() to reject when preventAbort is true","status":"FAIL"},{"name":"an undefined rejection from pull should cause pipeTo() to reject when preventAbort is false","status":"FAIL"},{"name":"an undefined rejection from write should cause pipeTo() to reject when preventCancel is true","status":"FAIL"},{"name":"an undefined rejection from write should cause pipeTo() to reject when preventCancel is false","status":"FAIL"},{"name":"pipeTo() should reject if an option getter grabs a writer","status":"FAIL"},{"name":"pipeTo() promise should resolve if null is passed","status":"FAIL"}]}