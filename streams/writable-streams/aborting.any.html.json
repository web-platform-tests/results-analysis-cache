{"status":"OK","subtests":[{"name":"Aborting a WritableStream before it starts should cause the writer's unsettled ready promise to reject","status":"PASS"},{"name":"Aborting a WritableStream should cause the writer's fulfilled ready promise to reset to a rejected one","status":"PASS"},{"name":"abort() on a released writer rejects","status":"PASS"},{"name":"Aborting a WritableStream immediately prevents future writes","status":"PASS"},{"name":"Aborting a WritableStream prevents further writes after any that are in progress","status":"PASS"},{"name":"Fulfillment value of writer.abort() call must be undefined even if the underlying sink returns a non-undefined value","status":"PASS"},{"name":"WritableStream if sink's abort throws, the promise returned by writer.abort() rejects","status":"PASS"},{"name":"WritableStream if sink's abort throws, the promise returned by multiple writer.abort()s is the same and rejects","status":"PASS"},{"name":"WritableStream if sink's abort throws, the promise returned by ws.abort() rejects","status":"PASS"},{"name":"WritableStream if sink's abort throws, for an abort performed during a write, the promise returned by ws.abort() rejects","status":"PASS"},{"name":"Aborting a WritableStream passes through the given reason","status":"PASS"},{"name":"Aborting a WritableStream puts it in an errored state with the error passed to abort()","status":"PASS"},{"name":"Aborting a WritableStream causes any outstanding write() promises to be rejected with the reason supplied","status":"PASS"},{"name":"Closing but then immediately aborting a WritableStream causes the stream to error","status":"PASS"},{"name":"Closing a WritableStream and aborting it while it closes causes the stream to ignore the abort attempt","status":"PASS"},{"name":"Aborting a WritableStream after it is closed is a no-op","status":"PASS"},{"name":"WritableStream should NOT call underlying sink's close if no abort is supplied (historical)","status":"PASS"},{"name":"returning a thenable from abort() should work","status":"PASS"},{"name":".closed should not resolve before fulfilled write()","status":"PASS"},{"name":".closed should not resolve before rejected write(); write() error should not overwrite abort() error","status":"PASS"},{"name":"writes should be satisfied in order when aborting","status":"PASS"},{"name":"writes should be satisfied in order after rejected write when aborting","status":"PASS"},{"name":"close() should reject with abort reason why abort() is first error","status":"PASS"},{"name":"underlying abort() should not be called until underlying write() completes","status":"PASS"},{"name":"underlying abort() should not be called if underlying close() has started","status":"PASS"},{"name":"if underlying close() has started and then rejects, the abort() and close() promises should reject with the underlying close rejection reason","status":"PASS"},{"name":"an abort() that happens during a write() should trigger the underlying abort() even with a close() queued","status":"PASS"},{"name":"if a writer is created for a stream with a pending abort, its ready should be rejected with the abort error","status":"PASS"},{"name":"writer close() promise should resolve before abort() promise","status":"PASS"},{"name":"writer.ready should reject on controller error without waiting for underlying write","status":"PASS"},{"name":"writer.abort() while there is an in-flight write, and then finish the write with rejection","status":"PASS"},{"name":"writer.abort(), controller.error() while there is an in-flight write, and then finish the write","status":"PASS"},{"name":"writer.abort(), controller.error() while there is an in-flight close, and then finish the close","status":"PASS"},{"name":"controller.error(), writer.abort() while there is an in-flight write, and then finish the write","status":"PASS"},{"name":"controller.error(), writer.abort() while there is an in-flight close, and then finish the close","status":"PASS"},{"name":"releaseLock() while aborting should reject the original closed promise","status":"PASS"},{"name":"releaseLock() during delayed async abort() should reject the writer.closed promise","status":"PASS"},{"name":"sink abort() should not be called until sink start() is done","status":"PASS"},{"name":"if start attempts to error the controller after abort() has been called, then it should lose","status":"PASS"},{"name":"stream abort() promise should still resolve if sink start() rejects","status":"PASS"},{"name":"writer abort() during sink start() should replace the writer.ready promise synchronously","status":"PASS"},{"name":"promises returned from other writer methods should be rejected when writer abort() happens during sink start()","status":"PASS"},{"name":"abort() should succeed despite rejection from write","status":"PASS"},{"name":"abort() should be rejected with the rejection returned from close()","status":"PASS"},{"name":"a rejecting sink.write() should not prevent sink.abort() from being called","status":"PASS"},{"name":"when start errors after stream abort(), underlying sink abort() should be called anyway","status":"PASS"},{"name":"when calling abort() twice on the same stream, both should give the same promise that fulfills with undefined","status":"PASS"},{"name":"when calling abort() twice on the same stream, but sequentially so so there's no pending abort the second time, both should fulfill with undefined","status":"PASS"},{"name":"calling abort() on an errored stream should fulfill with undefined","status":"PASS"},{"name":"sink abort() should not be called if stream was erroring due to controller.error() before abort() was called","status":"PASS"},{"name":"sink abort() should not be called if stream was erroring due to bad strategy before abort() was called","status":"PASS"},{"name":"abort with no arguments should set the stored error to undefined","status":"PASS"},{"name":"abort with an undefined argument should set the stored error to undefined","status":"PASS"},{"name":"abort with a string argument should set the stored error to that argument","status":"PASS"},{"name":"abort on a locked stream should reject","status":"PASS"}]}