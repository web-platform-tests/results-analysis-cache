{"status":"OK","subtests":[{"name":"fulfillment value of writer.close() call must be undefined even if the underlying sink returns a non-undefined value","status":"PASS"},{"name":"when sink calls error asynchronously while sink close is in-flight, the stream should not become errored","status":"PASS"},{"name":"when sink calls error synchronously while closing, the stream should not become errored","status":"PASS"},{"name":"when the sink throws during close, and the close is requested while a write is still in-flight, the stream should become errored during the close","status":"PASS"},{"name":"releaseLock on a stream with a pending write in which the stream has been errored","status":"PASS"},{"name":"releaseLock on a stream with a pending close in which controller.error() was called","status":"PASS"},{"name":"when close is called on a WritableStream in writable state, ready should return a fulfilled promise","status":"PASS"},{"name":"when close is called on a WritableStream in waiting state, ready promise should be fulfilled","status":"PASS"},{"name":"when close is called on a WritableStream in waiting state, ready should be fulfilled immediately even if close takes a long time","status":"PASS"},{"name":"returning a thenable from close() should work","status":"PASS"},{"name":"releaseLock() should not change the result of sync close()","status":"PASS"},{"name":"releaseLock() should not change the result of async close()","status":"PASS"},{"name":"close() should set state to CLOSED even if writer has detached","status":"PASS"},{"name":"the promise returned by async abort during close should resolve","status":"PASS"},{"name":"promises must fulfill/reject in the expected order on closure","status":"PASS"},{"name":"promises must fulfill/reject in the expected order on aborted closure","status":"PASS"},{"name":"promises must fulfill/reject in the expected order on aborted and errored closure","status":"PASS"},{"name":"close() should not reject until no sink methods are in flight","status":"PASS"},{"name":"ready promise should be initialised as fulfilled for a writer on a closed stream","status":"PASS"},{"name":"close() on a writable stream should work","status":"PASS"},{"name":"close() on a locked stream should reject","status":"PASS"},{"name":"close() on an erroring stream should reject","status":"PASS"},{"name":"close() on an errored stream should reject","status":"PASS"},{"name":"close() on an closed stream should reject","status":"PASS"},{"name":"close() on a stream with a pending close should reject","status":"PASS"}]}