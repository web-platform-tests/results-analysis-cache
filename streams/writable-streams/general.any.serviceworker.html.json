{"status":"OK","subtests":[{"name":"desiredSize on a released writer","status":"PASS"},{"name":"desiredSize initial value","status":"PASS"},{"name":"desiredSize on a writer for a closed stream","status":"PASS"},{"name":"desiredSize on a writer for an errored stream","status":"PASS"},{"name":"ws.getWriter() on a closing WritableStream","status":"PASS"},{"name":"ws.getWriter() on a closed WritableStream","status":"PASS"},{"name":"ws.getWriter() on an aborted WritableStream","status":"PASS"},{"name":"ws.getWriter() on an errored WritableStream","status":"PASS"},{"name":"closed and ready on a released writer","status":"PASS"},{"name":"WritableStream should call underlying sink methods as methods","status":"PASS"},{"name":"methods should not not have .apply() or .call() called","status":"PASS"},{"name":"WritableStream's strategy.size should not be called as a method","status":"PASS"},{"name":"redundant releaseLock() is no-op","status":"PASS"},{"name":"ready promise should fire before closed on releaseLock","status":"PASS"},{"name":"Subclassing WritableStream should work","status":"PASS"},{"name":"the locked getter should return true if the stream has a writer","status":"PASS"}]}