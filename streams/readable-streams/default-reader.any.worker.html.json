{"status":"OK","subtests":[{"name":"Can get the ReadableStreamDefaultReader constructor indirectly","status":"PASS"},{"name":"ReadableStreamDefaultReader constructor should get a ReadableStream object as argument","status":"PASS"},{"name":"ReadableStreamDefaultReader instances should have the correct list of properties","status":"PASS"},{"name":"ReadableStreamDefaultReader closed should always return the same promise object","status":"PASS"},{"name":"Constructing a ReadableStreamDefaultReader directly should fail if the stream is already locked (via direct construction)","status":"PASS"},{"name":"Getting a ReadableStreamDefaultReader via getReader should fail if the stream is already locked (via direct construction)","status":"PASS"},{"name":"Constructing a ReadableStreamDefaultReader directly should fail if the stream is already locked (via getReader)","status":"PASS"},{"name":"Getting a ReadableStreamDefaultReader via getReader should fail if the stream is already locked (via getReader)","status":"PASS"},{"name":"Constructing a ReadableStreamDefaultReader directly should be OK if the stream is closed","status":"PASS"},{"name":"Constructing a ReadableStreamDefaultReader directly should be OK if the stream is errored","status":"PASS"},{"name":"Reading from a reader for an empty stream will wait until a chunk is available","status":"PASS"},{"name":"cancel() on a reader does not release the reader","status":"PASS"},{"name":"closed should be fulfilled after stream is closed (.closed access before acquiring)","status":"PASS"},{"name":"closed should be rejected after reader releases its lock (multiple stream locks)","status":"PASS"},{"name":"Multiple readers can access the stream in sequence","status":"PASS"},{"name":"Cannot use an already-released reader to unlock a stream again","status":"PASS"},{"name":"cancel() on a released reader is a no-op and does not pass through","status":"PASS"},{"name":"Getting a second reader after erroring the stream and releasing the reader should succeed","status":"PASS"},{"name":"ReadableStreamDefaultReader closed promise should be rejected with undefined if that is the error","status":"PASS"},{"name":"ReadableStreamDefaultReader: if start rejects with no parameter, it should error the stream with an undefined error","status":"PASS"},{"name":"Erroring a ReadableStream after checking closed should reject ReadableStreamDefaultReader closed promise","status":"PASS"},{"name":"Erroring a ReadableStream before checking closed should reject ReadableStreamDefaultReader closed promise","status":"PASS"},{"name":"Reading twice on a stream that gets closed","status":"PASS"},{"name":"Reading twice on a closed stream","status":"PASS"},{"name":"Reading twice on an errored stream","status":"PASS"},{"name":"Reading twice on a stream that gets errored","status":"PASS"},{"name":"getReader() should call ToString() on mode","status":"PASS"},{"name":"controller.close() should clear the list of pending read requests","status":"PASS"}]}