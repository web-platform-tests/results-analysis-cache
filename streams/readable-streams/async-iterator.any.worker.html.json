{"status":"OK","subtests":[{"name":"Async iterator instances should have the correct list of properties","status":"PASS"},{"name":"values() throws if there's already a lock","status":"PASS"},{"name":"return() should unlock the stream synchronously when preventCancel = false","status":"PASS"},{"name":"return() should unlock the stream synchronously when preventCancel = true","status":"PASS"},{"name":"Async-iterating a push source","status":"PASS"},{"name":"Async-iterating a pull source","status":"PASS"},{"name":"Async-iterating a push source with undefined values","status":"PASS"},{"name":"Async-iterating a pull source with undefined values","status":"PASS"},{"name":"Async-iterating a pull source manually","status":"PASS"},{"name":"Async-iterating an errored stream throws","status":"PASS"},{"name":"Async-iterating a closed stream never executes the loop body, but works fine","status":"PASS"},{"name":"Async-iterating an empty but not closed/errored stream never executes the loop body and stalls the async function","status":"PASS"},{"name":"Async-iterating a partially consumed stream","status":"PASS"},{"name":"Cancellation behavior when throwing inside loop body; preventCancel = false","status":"PASS"},{"name":"Cancellation behavior when throwing inside loop body; preventCancel = true","status":"PASS"},{"name":"Cancellation behavior when breaking inside loop body; preventCancel = false","status":"PASS"},{"name":"Cancellation behavior when breaking inside loop body; preventCancel = true","status":"PASS"},{"name":"Cancellation behavior when returning inside loop body; preventCancel = false","status":"PASS"},{"name":"Cancellation behavior when returning inside loop body; preventCancel = true","status":"PASS"},{"name":"Cancellation behavior when manually calling return(); preventCancel = false","status":"PASS"},{"name":"Cancellation behavior when manually calling return(); preventCancel = true","status":"PASS"},{"name":"next() rejects if the stream errors","status":"PASS"},{"name":"return() does not rejects if the stream has not errored yet","status":"PASS"},{"name":"return() rejects if the stream has errored","status":"PASS"},{"name":"next() that succeeds; next() that reports an error; next()","status":"PASS"},{"name":"next() that succeeds; next() that reports an error(); next() [no awaiting]","status":"PASS"},{"name":"next() that succeeds; next() that reports an error(); return()","status":"PASS"},{"name":"next() that succeeds; next() that reports an error(); return() [no awaiting]","status":"PASS"},{"name":"next() that succeeds; return()","status":"PASS"},{"name":"next() that succeeds; return() [no awaiting]","status":"PASS"},{"name":"return(); next()","status":"PASS"},{"name":"return(); next() [no awaiting]","status":"PASS"},{"name":"return(); return()","status":"PASS"},{"name":"return(); return() [no awaiting]","status":"PASS"},{"name":"Acquiring a reader after exhaustively async-iterating a stream","status":"PASS"},{"name":"Acquiring a reader after return()ing from a stream that errors","status":"PASS"},{"name":"Acquiring a reader after partially async-iterating a stream","status":"PASS"},{"name":"Acquiring a reader and reading the remaining chunks after partially async-iterating a stream with preventCancel = true","status":"PASS"},{"name":"close() while next() is pending","status":"PASS"}]}