{"status":"OK","subtests":[{"name":"@@asyncIterator() method is === to getIterator() method","status":"PASS"},{"name":"Async iterator instances should have the correct list of properties","status":"FAIL"},{"name":"Async-iterating a push source","status":"FAIL"},{"name":"Async-iterating a pull source","status":"FAIL"},{"name":"Async-iterating a pull source manually","status":"FAIL"},{"name":"Async-iterating an errored stream throws","status":"FAIL"},{"name":"Async-iterating a closed stream never executes the loop body, but works fine","status":"FAIL"},{"name":"Async-iterating an empty but not closed/errored stream never executes the loop body and stalls the async function","status":"FAIL"},{"name":"Async-iterating a partially consumed stream","status":"FAIL"},{"name":"Cancellation behavior when throwing inside loop body; preventCancel = false","status":"FAIL"},{"name":"Cancellation behavior when throwing inside loop body; preventCancel = true","status":"FAIL"},{"name":"Cancellation behavior when breaking inside loop body; preventCancel = false","status":"FAIL"},{"name":"Cancellation behavior when breaking inside loop body; preventCancel = true","status":"FAIL"},{"name":"Cancellation behavior when returning inside loop body; preventCancel = false","status":"FAIL"},{"name":"Cancellation behavior when returning inside loop body; preventCancel = true","status":"FAIL"},{"name":"Cancellation behavior when manually calling return(); preventCancel = false","status":"FAIL"},{"name":"Cancellation behavior when manually calling return(); preventCancel = true","status":"FAIL"},{"name":"Calling return() twice rejects","status":"FAIL"},{"name":"next()'s fulfillment value has the right shape","status":"FAIL"},{"name":"calling return() while there are pending reads rejects","status":"FAIL"},{"name":"getIterator() throws if there's already a lock","status":"FAIL"},{"name":"Acquiring a reader after exhaustively async-iterating a stream","status":"FAIL"},{"name":"Acquiring a reader after partially async-iterating a stream","status":"FAIL"},{"name":"Acquiring a reader and reading the remaining chunks after partially async-iterating a stream with preventCancel = true","status":"FAIL"},{"name":"calling next() after return() should reject","status":"FAIL"},{"name":"return() should unlock the stream synchronously when preventCancel = false","status":"FAIL"},{"name":"return() should unlock the stream synchronously when preventCancel = true","status":"FAIL"}]}