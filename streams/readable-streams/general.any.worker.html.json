{"status":"OK","subtests":[{"name":"ReadableStream can be constructed with no errors","status":"PASS"},{"name":"ReadableStream can't be constructed with garbage","status":"PASS"},{"name":"ReadableStream can't be constructed with an invalid type","status":"FAIL"},{"name":"ReadableStream constructor should throw for non-function start arguments","status":"PASS"},{"name":"ReadableStream constructor will not tolerate initial garbage as cancel argument","status":"PASS"},{"name":"ReadableStream constructor will not tolerate initial garbage as pull argument","status":"PASS"},{"name":"ReadableStream start should be called with the proper thisArg","status":"PASS"},{"name":"ReadableStream start controller parameter should be extensible","status":"PASS"},{"name":"default ReadableStream getReader() should only accept mode:undefined","status":"FAIL"},{"name":"ReadableStream should be able to call start method within prototype chain of its source","status":"PASS"},{"name":"ReadableStream start should be able to return a promise","status":"PASS"},{"name":"ReadableStream start should be able to return a promise and reject it","status":"PASS"},{"name":"ReadableStream should be able to enqueue different objects.","status":"PASS"},{"name":"ReadableStream: if pull rejects, it should error the stream","status":"PASS"},{"name":"ReadableStream: should only call pull once upon starting the stream","status":"PASS"},{"name":"ReadableStream: should call pull when trying to read from a started, empty stream","status":"PASS"},{"name":"ReadableStream: should only call pull once on a non-empty stream read from before start fulfills","status":"PASS"},{"name":"ReadableStream: should only call pull once on a non-empty stream read from after start fulfills","status":"PASS"},{"name":"ReadableStream: should call pull in reaction to read()ing the last chunk, if not draining","status":"PASS"},{"name":"ReadableStream: should not call pull() in reaction to read()ing the last chunk, if draining","status":"PASS"},{"name":"ReadableStream: should not call pull until the previous pull call's promise fulfills","status":"PASS"},{"name":"ReadableStream: should pull after start, and after every read","status":"PASS"},{"name":"ReadableStream: should not call pull after start if the stream is now closed","status":"PASS"},{"name":"ReadableStream: should call pull after enqueueing from inside pull (with no read requests), if strategy allows","status":"PASS"},{"name":"ReadableStream pull should be able to close a stream.","status":"PASS"},{"name":"ReadableStream pull should be able to error a stream.","status":"PASS"},{"name":"ReadableStream pull should be able to error a stream and throw.","status":"PASS"},{"name":"ReadableStream: enqueue should throw when the stream is readable but draining","status":"PASS"},{"name":"ReadableStream: enqueue should throw when the stream is closed","status":"PASS"},{"name":"ReadableStream: should call underlying source methods as methods","status":"PASS"},{"name":"ReadableStream: desiredSize when closed","status":"PASS"},{"name":"ReadableStream: desiredSize when errored","status":"PASS"},{"name":"Subclassing ReadableStream should work","status":"PASS"},{"name":"ReadableStream strategies: the default strategy should give desiredSize of 1 to start, decreasing by 1 per enqueue","status":"PASS"},{"name":"ReadableStream strategies: the default strategy should continue giving desiredSize of 1 if the chunks are read immediately","status":"PASS"},{"name":"ReadableStream integration test: adapting a random push source","status":"PASS"},{"name":"ReadableStream integration test: adapting a sync pull source","status":"PASS"},{"name":"ReadableStream integration test: adapting an async pull source","status":"PASS"}]}