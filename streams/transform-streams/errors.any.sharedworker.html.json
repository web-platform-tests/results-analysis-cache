{"status":"OK","subtests":[{"name":"TransformStream errors thrown in transform put the writable and readable in an errored state","status":"PASS"},{"name":"TransformStream errors thrown in flush put the writable and readable in an errored state","status":"PASS"},{"name":"errored TransformStream should not enqueue new chunks","status":"PASS"},{"name":"TransformStream transformer.start() rejected promise should error the stream","status":"PASS"},{"name":"when controller.error is followed by a rejection, the error reason should come from controller.error","status":"PASS"},{"name":"TransformStream constructor should throw when start does","status":"PASS"},{"name":"when strategy.size throws inside start(), the constructor should throw the same error","status":"PASS"},{"name":"when strategy.size calls controller.error() then throws, the constructor should throw the first error","status":"PASS"},{"name":"cancelling the readable side should error the writable","status":"PASS"},{"name":"it should be possible to error the readable between close requested and complete","status":"PASS"},{"name":"an exception from transform() should error the stream if terminate has been requested but not completed","status":"PASS"},{"name":"abort should set the close reason for the writable when it happens before cancel during start, but cancel should still succeed","status":"PASS"},{"name":"abort should set the close reason for the writable when it happens before cancel during underlying sink write, but cancel should still succeed","status":"PASS"},{"name":"controller.error() should do nothing the second time it is called","status":"PASS"},{"name":"controller.error() should do nothing after readable.cancel()","status":"PASS"},{"name":"controller.error() should do nothing after writable.abort() has completed","status":"PASS"},{"name":"controller.error() should do nothing after a transformer method has thrown an exception","status":"PASS"},{"name":"erroring during write with backpressure should result in the write failing","status":"PASS"},{"name":"a write() that was waiting for backpressure should reject if the writable is aborted","status":"PASS"},{"name":"the readable should be errored with the reason passed to the writable abort() method","status":"PASS"}]}