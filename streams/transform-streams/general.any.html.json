{"status":"OK","subtests":[{"name":"TransformStream can be constructed with a transform function","status":"PASS"},{"name":"TransformStream can be constructed with no transform function","status":"PASS"},{"name":"TransformStream writable starts in the writable state","status":"PASS"},{"name":"Identity TransformStream: can read from readable what is put into writable","status":"PASS"},{"name":"Uppercaser sync TransformStream: can read from readable transformed version of what is put into writable","status":"PASS"},{"name":"Uppercaser-doubler sync TransformStream: can read both chunks put into the readable","status":"PASS"},{"name":"Uppercaser async TransformStream: can read from readable transformed version of what is put into writable","status":"PASS"},{"name":"Uppercaser-doubler async TransformStream: can read both chunks put into the readable","status":"PASS"},{"name":"TransformStream: by default, closing the writable closes the readable (when there are no queued writes)","status":"PASS"},{"name":"TransformStream: by default, closing the writable waits for transforms to finish before closing both","status":"PASS"},{"name":"TransformStream: by default, closing the writable closes the readable after sync enqueues and async done","status":"PASS"},{"name":"TransformStream: by default, closing the writable closes the readable after async enqueues and async done","status":"PASS"},{"name":"Transform stream should call transformer methods as methods","status":"PASS"},{"name":"methods should not not have .apply() or .call() called","status":"PASS"},{"name":"TransformStream start, transform, and flush should be strictly ordered","status":"PASS"},{"name":"it should be possible to call transform() synchronously","status":"PASS"},{"name":"closing the writable should close the readable when there are no queued chunks, even with backpressure","status":"PASS"},{"name":"enqueue() should throw after controller.terminate()","status":"PASS"},{"name":"enqueue() should throw after readable.cancel()","status":"PASS"},{"name":"controller.terminate() should do nothing the second time it is called","status":"PASS"},{"name":"terminate() should do nothing after readable.cancel()","status":"PASS"},{"name":"start() should not be called twice","status":"PASS"},{"name":"specifying a defined readableType should throw","status":"PASS"},{"name":"specifying a defined writableType should throw","status":"PASS"},{"name":"Subclassing TransformStream should work","status":"PASS"}]}