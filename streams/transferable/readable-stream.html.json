{"status":"OK","subtests":[{"name":"sending one chunk through a transferred stream should work","status":"PASS"},{"name":"sending ten chunks through a transferred stream should work","status":"PASS"},{"name":"sending ten chunks one at a time should work","status":"PASS"},{"name":"sending ten chunks on demand should work","status":"PASS"},{"name":"transferring a stream should relieve backpressure","status":"PASS"},{"name":"transferring a stream should add one chunk to the queue size","status":"PASS"},{"name":"the extra queue from transferring is counted in chunks","status":"PASS"},{"name":"cancel should be propagated to the original","status":"PASS"},{"name":"cancel should abort a pending read()","status":"PASS"},{"name":"stream cancel should not wait for underlying source cancel","status":"PASS"},{"name":"serialization should not happen until the value is read","status":"PASS"},{"name":"transferring a non-serializable chunk should error both sides","status":"PASS"},{"name":"errors should be passed through","status":"PASS"},{"name":"race between cancel() and error() should leave sides in different states","status":"PASS"},{"name":"race between cancel() and close() should be benign","status":"PASS"},{"name":"race between cancel() and enqueue() should be benign","status":"PASS"}]}