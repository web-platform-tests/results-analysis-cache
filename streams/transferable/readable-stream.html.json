{"status":"OK","subtests":[{"name":"sending one chunk through a transferred stream should work","status":"FAIL"},{"name":"sending ten chunks through a transferred stream should work","status":"FAIL"},{"name":"sending ten chunks one at a time should work","status":"FAIL"},{"name":"sending ten chunks on demand should work","status":"FAIL"},{"name":"transferring a stream should relieve backpressure","status":"FAIL"},{"name":"transferring a stream should add one chunk to the queue size","status":"FAIL"},{"name":"the extra queue from transferring is counted in chunks","status":"FAIL"},{"name":"cancel should be propagated to the original","status":"FAIL"},{"name":"cancel should abort a pending read()","status":"FAIL"},{"name":"stream cancel should not wait for underlying source cancel","status":"FAIL"},{"name":"serialization should not happen until the value is read","status":"FAIL"},{"name":"transferring a non-serializable chunk should error both sides","status":"FAIL"},{"name":"errors should be passed through","status":"FAIL"},{"name":"race between cancel() and error() should leave sides in different states","status":"FAIL"},{"name":"race between cancel() and close() should be benign","status":"FAIL"},{"name":"race between cancel() and enqueue() should be benign","status":"FAIL"}]}