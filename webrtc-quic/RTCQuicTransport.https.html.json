{"status":"OK","subtests":[{"name":"RTCQuicTransport initial properties are set.","status":"PASS"},{"name":"RTCQuicTransport constructor throws if passed a closed RTCIceTransport.","status":"PASS"},{"name":"RTCQuicTransport constructor throws if passed an RTCIceTransport that already has an active RTCQuicTransport.","status":"PASS"},{"name":"RTCQuicTransport constructor throws if passed an RTCIceTransport that came from an RTCPeerConnection.","status":"PASS"},{"name":"stop() changes state to 'closed'.","status":"PASS"},{"name":"RTCIceTransport.stop() changes RTCQuicTransport.state to 'closed'.","status":"PASS"},{"name":"Two RTCQuicTransports connect to each other.","status":"PASS"},{"name":"stop() fires a statechange event to 'closed' on the remote transport","status":"PASS"},{"name":"connect() changes state to 'connecting'.","status":"PASS"},{"name":"connect() throws if already called connect().","status":"PASS"},{"name":"connect() throws if already called listen().","status":"PASS"},{"name":"connect() throws after stop().","status":"PASS"},{"name":"connect() throws if called after RTCIceTransport has stopped.","status":"PASS"},{"name":"listen() changes state to 'connecting'.","status":"PASS"},{"name":"listen() throws if already called connect().","status":"PASS"},{"name":"listen() throws if already called listen().","status":"PASS"},{"name":"listen() throws after stop().","status":"PASS"},{"name":"listen() throws if called after RTCIceTransport has stopped.","status":"PASS"},{"name":"RTCQuicTransport.getKey() attribute is 16 bytes.","status":"PASS"},{"name":"listen() throws if given an empty key.","status":"PASS"},{"name":"Cannot mutate key retrieved from getKey().","status":"PASS"},{"name":"Stats returned by getStats() are present.","status":"PASS"},{"name":"getStats() returns proper stream counts after creating streams.","status":"PASS"},{"name":"Two separate stats returned by getStats() give different timestamps.","status":"PASS"},{"name":"getStats() promises immediately rejected with InvalidStateError if called before 'connecting'.","status":"PASS"},{"name":"getStats() promises rejected  with InvalidStateError if stop() is called before being fulfilled.","status":"PASS"},{"name":"getStats() promises rejected  with InvalidStateError if RTCIceTransport calls stop() before being fulfilled.","status":"PASS"},{"name":"getStats() promises immediately rejected if called after 'closed' state.","status":"PASS"},{"name":"sendDatagram() throws InvalidStateError if called before 'connected'.","status":"PASS"},{"name":"sendDatagram() throws InvalidStateError if called when 'closed'.","status":"PASS"},{"name":"maxDatagramLength 0 before connected.","status":"PASS"},{"name":"maxDatagramLength larger than 0 after connected.","status":"PASS"},{"name":"sendDatagram() throws InvalidStateError if called with data larger than maxDatagramLength()","status":"PASS"},{"name":"sendDatagram() sends a datagram to remote side","status":"PASS"},{"name":"sendDatagram() sends a multiple datagrams to remote side","status":"PASS"},{"name":"readyToSendDatagram() promise immediately rejected if called before connecting","status":"PASS"},{"name":"readyToSendDatagram() promise immediately rejected if called after 'closed' state.","status":"PASS"},{"name":"receiveDatagrams() promise immediately rejected if called before connecting.","status":"PASS"},{"name":"receiveDatagrams() promise immediately rejected if called after 'closed' state.","status":"PASS"},{"name":"receiveDatagrams() promise rejected  with InvalidStateError if stop() is called before being fulfilled.","status":"PASS"},{"name":"receiveDatagrams() promises rejected  with InvalidStateError if RTCIceTransport calls stop() before being fulfilled.","status":"PASS"}]}