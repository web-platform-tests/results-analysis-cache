{"status":"OK","subtests":[{"name":"global setup","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-addresses-absolute.json","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-addresses-invalid.json","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-addresses.json","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-invalid-json.json","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-schema-normalization.json","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-schema-scope.json","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-schema-specifier-map.json","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-schema-toplevel.json","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-scope-keys.json","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-specifier-keys.json","status":"PASS"},{"name":"Test helper: fetching and sanity checking test JSON: resources/parsing-trailing-slashes.json","status":"PASS"},{"name":"global cleanup","status":"PASS"},{"name":"Absolute URL addresses: should only accept absolute URL addresses with fetch schemes","status":"FAIL"},{"name":"Absolute URL addresses: should parse absolute URLs, ignoring unparseable ones","status":"FAIL"},{"name":"Other invalid addresses: should ignore unprefixed strings that are not absolute URLs","status":"FAIL"},{"name":"Relative URL-like addresses: should accept strings prefixed with ./, ../, or /","status":"FAIL"},{"name":"Relative URL-like addresses: should not accept strings prefixed with ./, ../, or / for data: base URLs","status":"FAIL"},{"name":"Relative URL-like addresses: should accept the literal strings ./, ../, or / with no suffix","status":"FAIL"},{"name":"Relative URL-like addresses: should ignore percent-encoded variants of ./, ../, or /","status":"FAIL"},{"name":"Invalid JSON","status":"PASS"},{"name":"Normalization: should normalize empty import maps to have imports and scopes keys","status":"FAIL"},{"name":"Normalization: should normalize an import map without imports to have imports","status":"FAIL"},{"name":"Normalization: should normalize an import map without scopes to have scopes","status":"FAIL"},{"name":"Mismatching scopes schema: should throw if a scope's value is not an object: null","status":"PASS"},{"name":"Mismatching scopes schema: should throw if a scope's value is not an object: boolean","status":"PASS"},{"name":"Mismatching scopes schema: should throw if a scope's value is not an object: number","status":"PASS"},{"name":"Mismatching scopes schema: should throw if a scope's value is not an object: string","status":"PASS"},{"name":"Mismatching scopes schema: should throw if a scope's value is not an object: array","status":"PASS"},{"name":"Mismatching the specifier map schema: should ignore entries where the address is not a string","status":"FAIL"},{"name":"Mismatching the specifier map schema: should ignore entries where the specifier key is an empty string","status":"FAIL"},{"name":"Mismatching the top-level schema: should throw for top-level non-objects: null","status":"PASS"},{"name":"Mismatching the top-level schema: should throw for top-level non-objects: boolean","status":"PASS"},{"name":"Mismatching the top-level schema: should throw for top-level non-objects: number","status":"PASS"},{"name":"Mismatching the top-level schema: should throw for top-level non-objects: string","status":"PASS"},{"name":"Mismatching the top-level schema: should throw for top-level non-objects: array","status":"PASS"},{"name":"Mismatching the top-level schema: should throw if imports is a non-object: null","status":"PASS"},{"name":"Mismatching the top-level schema: should throw if imports is a non-object: boolean","status":"PASS"},{"name":"Mismatching the top-level schema: should throw if imports is a non-object: number","status":"PASS"},{"name":"Mismatching the top-level schema: should throw if imports is a non-object: string","status":"PASS"},{"name":"Mismatching the top-level schema: should throw if imports is a non-object: array","status":"PASS"},{"name":"Mismatching the top-level schema: should throw if scopes is a non-object: null","status":"PASS"},{"name":"Mismatching the top-level schema: should throw if scopes is a non-object: boolean","status":"PASS"},{"name":"Mismatching the top-level schema: should throw if scopes is a non-object: number","status":"PASS"},{"name":"Mismatching the top-level schema: should throw if scopes is a non-object: string","status":"PASS"},{"name":"Mismatching the top-level schema: should throw if scopes is a non-object: array","status":"PASS"},{"name":"Mismatching the top-level schema: should ignore unspecified top-level entries","status":"FAIL"},{"name":"Relative URL scope keys should work with no prefix","status":"FAIL"},{"name":"Relative URL scope keys should work with ./, ../, and / prefixes","status":"FAIL"},{"name":"Absolute URL scope keys should ignore relative URL scope keys when the base URL is a data: URL","status":"FAIL"},{"name":"Relative URL scope keys should work with ./, ../, or / with no suffix","status":"FAIL"},{"name":"Relative URL scope keys should work with /s, ?s, and #s","status":"FAIL"},{"name":"Relative URL scope keys should work with an empty string scope key","status":"FAIL"},{"name":"Relative URL scope keys should work with / suffixes","status":"FAIL"},{"name":"Relative URL scope keys should deduplicate based on URL parsing rules","status":"FAIL"},{"name":"Absolute URL scope keys should accept all absolute URL scope keys, with or without fetch schemes","status":"FAIL"},{"name":"Absolute URL scope keys should parse absolute URL scope keys, ignoring unparseable ones","status":"FAIL"},{"name":"Relative URL specifier keys should absolutize strings prefixed with ./, ../, or / into the corresponding URLs","status":"FAIL"},{"name":"Relative URL specifier keys should not absolutize strings prefixed with ./, ../, or / with a data: URL base","status":"FAIL"},{"name":"Relative URL specifier keys should absolutize the literal strings ./, ../, or / with no suffix","status":"FAIL"},{"name":"Relative URL specifier keys should work with /s, ?s, and #s","status":"FAIL"},{"name":"Relative URL specifier keys should ignore an empty string key","status":"FAIL"},{"name":"Relative URL specifier keys should treat percent-encoded variants of ./, ../, or / as bare specifiers","status":"FAIL"},{"name":"Relative URL specifier keys should deduplicate based on URL parsing rules","status":"FAIL"},{"name":"Absolute URL specifier keys should accept all absolute URL specifier keys, with or without fetch schemes","status":"FAIL"},{"name":"Absolute URL specifier keys should parse absolute URLs, treating unparseable ones as bare specifiers","status":"FAIL"},{"name":"Specifier keys should be sort correctly (issue #181) - Test #1","status":"FAIL"},{"name":"Specifier keys should be sort correctly (issue #181) - Test #2","status":"FAIL"},{"name":"Failing addresses: mismatched trailing slashes","status":"FAIL"}]}